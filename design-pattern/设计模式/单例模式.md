### 单例模式（Singleton Design Pattern）
一个类只允许创建一个对象（或者实例），那这个类就是一个单例类，这种设计模式就叫作单例设计模式，简称单例模式。

### 为什么要使用单例？
1. 表示全局唯一类
2. 处理资源访问冲突

### 实现单例时要考虑的基本因素
- 构造函数需要是 private 访问权限的，这样才能避免外部通过 new 创建实例；
- 考虑对象创建时的线程安全问题；
- 考虑是否支持延迟加载；
- 考虑 getInstance() 性能是否高（是否加锁）。

### 单例存在哪些问题
#### 1. 单例对 OOP 特性的支持不友好
**单例的使用方式违背了基于接口而非实现编程原则**，也就违背了广义上理解的 OOP 的抽象特性。

一旦你选择将某个类设计成到单例类，也就意味着放弃了**继承和多态**这两个强有力的面向对象特性，也就相当于损失了可以应对未来需求变化的扩展性。

#### 2. 单例会隐藏类之间的依赖关系
通过构造函数、参数传递等方式声明的类之间的依赖关系，我们通过查看函数的定义，就能很容易识别出来。但是，**单例类不需要显示创建、不需要依赖参数传递，在函数中直接调用就可以了**。如果代码比较复杂，这种调用关系就会非常隐蔽。

#### 3. 单例对代码的扩展性不友好
单例类在某些情况下会影响代码的扩展性、灵活性

#### 4. 单例对代码的可测试性不友好
#### 5. 单例不支持有参数的构造函数

### 单例有什么替代解决方案？
为了保证全局唯一，除了使用单例，我们还可以用静态方法来实现。不过，静态方法这种实现思路，并不能解决我们之前提到的问题。如果要完全解决这些问题，我们可能要从根上，寻找其他方式来实现全局唯一类了。比如，通过工厂模式、IOC 容器（比如 Spring IOC 容器）来保证，由程序员自己来保证（自己在编写代码的时候自己保证不要创建两个类对象）。

有人把单例当作反模式，主张杜绝在项目中使用。我个人觉得这有点极端。模式没有对错，关键看你怎么用。如果单例类并没有后续扩展的需求，并且不依赖外部系统，那设计成单例类就没有太大问题。对于一些全局的类，我们在其他地方 new 的话，还要在类之间传来传去，不如直接做成单例类，使用起来简洁方便。

