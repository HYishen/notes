### JAVA基础
#### 集合

##### List接口都有哪些实现？ArrayList与LinkedList的区别？一般什么时候使用ArrayList，什么时候使用LinkedList？
ArrayList的底层实现用的是数组，而LinkedList底层用的是链表。

ArrayList的查找操作比较快，而列表中的插入和删除操作比较慢。

LinkedList的查找操作比较慢，而列表中的插入和删除操作比较快。

##### HashMap
HashMap是基于哈希表来实现的，内部通过链表来解决冲突问题，容量不足（超过了阀值）时，会自动增长。

可以存储null键和null值，线程不安全

##### Hashtable
Hashtable同样是基于哈希表实现的，其内部也是通过单链表解决冲突问题，容量不足（超过了阀值）时，同样会自动增长。

无论key还是value都不能为null，线程安全。

##### ConcurrentHashMap
ConcurrentHashMap引入了一个“分段锁”的概念，具体可以理解为把一个大的Map拆分成N个小的HashTable，根据key.hashCode()来决定把key放到哪个HashTable中。

通过把整个Map分为N个Segment，可以提供相同的线程安全，但是效率提升N倍，默认提升16倍。(读操作不加锁，由于HashEntry的value变量是 volatile的，也能保证读取到最新的值。)

Hashtable的synchronized是针对整张Hash表的，即每次锁住整张表让线程独占，ConcurrentHashMap允许多个修改操作并发进行，其关键在于使用了锁分离技术

### JVM
#### Java的引用类型有哪几种？强引用、软引用、弱引用、幻象引用，他们的区别是什么？在发送gc时，强引用、软引用、弱引用对象是否还存活？

#### 故障定位
在故障定位(尤其是out of memory)和性能分析的时候，经常会用到一些文件辅助我们排除代码问题。这些文件记录了JVM运行期间的内存占用、线程执行等情况，这就是我们常说的dump文件。常用的有heap dump和thread dump（也叫javacore，或java dump）。我们可以这么理解：heap dump记录内存信息的，thread dump记录CPU信息。

### Spring
#### IOC
##### 循环依赖问题
https://zhuanlan.zhihu.com/p/84267654

#### AOP
##### 什么是AOP
OOP（Object-Oriented Programming）面向对象编程，允许开发者定义纵向的关系，但并不适用于定义横向的关系，导致了大量代码的重复，不利于各个模块的复用。

AOP（Aspect-Oriented Programming），一般称为面向切面编程，作为面向对象的一种补充，用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取并封装为一个可重用的模块，这个模块被命名为“切面”（Aspect），减少系统中的重复代码，降低了模块间的耦合度，同时提高了系统的可维护性。可用于权限认证、日志、事务处理等。

##### Spring AOP 和AspectJ AOP有什么区别？AOP有哪些实现方式？
AOP实现的关键在于代理模式，AOP代理主要分为静态代理和动态代理。静态代理的代表为AspectJ；动态代理则以Spring AOP为代表。

1. AspectJ是静态代理的增强。所谓静态代理，就是AOP框架会在编译阶段生成AOP代理类，因此也称为编译时增强，他会在编译阶段将AspectJ（切面）织入到Java字节码中，运行的时候就是增强之后的AOP对象。
2. Spring AOP使用的动态代理，所谓的动态代理就是说AOP框架不会去修改字节码，而是每次运行时在内存中临时为方法生成一个AOP对象。这个AOP对象包含了目标对象的全部方法，并且在特定的切点做了增强处理，并回调原对象的方法。

##### JDK动态代理和CGLIB动态代理的区别
Spring AOP中的动态代理主要有两种方式，JDK动态代理和CGLIB动态代理

- JDK动态代理只提供接口的代理，不支持类的代理。核心InvocationHandler接口和Proxy类，InvocationHandler通过invoke()方法反射来调用目标类中的代码，动态地将横切逻辑和业务逻辑编织在一起；接着，Proxy利用InvocationHandler动态创建一个符合某一接口的实例，生成目标类的代理对象。
- 如果代理类没有实现InvocationHandler接口，那么Spring AOP会选择使用CGLIB来动态代理目标类。CGLIB（Code Generation Library），是一个代码生成的类库，可以在运行时动态地生成指定类的一个子类，并覆盖其中特定方法来添加增强代码，从而实现AOP。CGLIB是通过继承的方式做的动态代理，因此如果某个类被标记为final，那么它是无法使用CGLIB做动态代理的。

静态代理与动态代理区别在于生成AOP代理对象的时机不同，相对来说AspectJ的静态代理方式具有更好的性能，但是AspectJ需要特定的编译器进行处理，而Spring AOP则无需特定的编译器处理。

> InvocationHandler的invoke(Object proxy, Method method, Object[] args): proxy是最终生成的代理实例; method是被代理目标实例的某个具体方法; args是被代理目标实例某个方法的具体入参，在方法反射调用时使用。

##### 如何理解Spring中的代理？
将Advice应用于目标对象后创建的对象称为代理。在客户端对象的情况下，目标对象和代理对象是相同的。

Advice + Target Object = Proxy

##### 解释一下Spring AOP里面的几个名词
1. 切面（Aspect）: 切面是通知和切点的结合。通知和切点共同定义了切面的全部内容。在Spring AOP中，切面可以使用通用类（基于模式的风格）或者在普通类中以@AspectJ注解来实现。
2. 连接点（Join point）: 指方法，在Spring AOP中，一个连接点总是代表一个方法的执行。应用可能有数以千计的时机应用通知。这些时机被称为连接点。连接点是在应用执行过程中能够插入切面的一个点。这个点可以是调用方法时、抛出异常时、甚至修改一个字段时。切面代码可以利用这些点插入到应用的正常流程之中，并添加新的行为。

#### 注解
##### Spring元注解
```
A meta-annotation is an annotation that is declared on another annotation.

元注解是在另一个注解上声明的注解。
```

##### Spring模式注解
```
A stereotype annotation is an annotation that is used to declare the role that a component plays within the application.

stereotype annotation是用于声明组件在应用程序中扮演的角色的注解。
```

##### Spring组合注解
```
A composed annotation is an annotation that is meta-annotated with one or more annotations with the intent of combining the behavior associated with those meta-annotations into a single custom annotation.

组合注解是一种注解，它使用一个或多个注解进行元注解，目的是将与那些元注解关联的行为组合到单个自定义注解中。
```

### Spring boot
#### Spring Boot 的自动配置是如何实现的?
这个是因为@SpringBootApplication 注解的原因，在上一个问题中已经提到了这个注解。我们知道 @SpringBootApplication 看作是 @Configuration、@EnableAutoConfiguration、@ComponentScan 注解的集合。

- @EnableAutoConfiguration：启用 SpringBoot 的自动配置机制

### Spring Cloud

### kafka

### Redis

### MySQL

### 网络协议

### 设计模式
