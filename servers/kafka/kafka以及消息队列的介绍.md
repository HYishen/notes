### kafka定义
Apache kafka是一个分布式的流平台。

一个流平台有三个核心的能力：
- 发布和订阅一个流的记录，类似于消息队列或者企业消息系统。
- 以容错持久的方式存储流记录。
- 当流记录出现时处理它们。

kafka一般被用于两大类应用程序：
- 建立实时流数据管道，以可靠地在系统或应用程序之间获取数据
- 构建实时流应用程序，以转换或响应数据流

### kafka的用途
#### 作为消息系统
Kafka的流概念与传统的企业消息传递系统相比如何？

消息系统有两种传统的模型：queuing 和 publish-subscribe模型。在队列中，一组consumer可以从服务器中读取内容，并且每条记录都将转到其中一个consumer。 在发布-订阅记录中广播给所有consumer。这两个模型中的每一个都有优点和缺点。 排队的优势在于，它允许您将数据处理划分到多个consumer实例上，从而扩展处理量。不幸的是，队列不是multi-subscriber的—一次读取之后数据就丢失了。 发布\/订阅允许您将数据广播到多个进程，但是由于每条消息都传递给每个订阅者，因此无法扩展处理。

kafka的consumer group概念概括了queuing 和 publish-subscribe这两个概念。与队列一样，consumer group允许你将处理划分为一组进程（consumer group的成员）。 与发布订阅一样，Kafka允许你将消息广播到多个consumer group。

Kafka模型的优点在于，每个topic都具有这些属性-可以扩展处理范围，并且是多订阅者-无需选择其中一个。

与传统的消息传递系统相比，Kafka还具有更强的有序性保证。

传统队列将记录按顺序保留在服务器上，如果多个使用者从队列中消费，则服务器将按记录的存储顺序分发记录。但是，尽管服务器按顺序分发记录，但是这些记录是异步传递给consumer的，因此它们可能在不同的consumer上乱序到达。这实际上意味着在并行使用的情况下会丢失记录的顺序。消息传递系统通常通过“exclusive consumer”的概念来解决此问题，该概念仅允许一个进程从队列中使用，但是，这当然意味着在处理中没有并行性。

kafka可以做得更好。通过在topic内的parallelism—the partition—概念，Kafka能够在consumer进程池中提供有序性保证和负载均衡。这是通过将topic中的partition分配给consumer group中的consumer来实现的，以便每个partition都由组中的一个consumer消费。通过这样做，我们确保consumer是该partition的唯一读取者，并按顺序消费数据。由于存在许多partition，因此仍然可以平衡许多consumer实例上的负载。 但是请注意，consumer group中的consumer实例不能超过partition（超过partition的consumer就闲置了）。

#### Kafka作为存储系统
任何允许发布与使用无关的消息的消息队列都有效地充当了运行中消息的存储系统。 Kafka的不同之处在于它是一个非常好的存储系统。

写入Kafka的数据将写入磁盘并进行复制以实现容错功能。 Kafka允许生产者等待确认，以便直到完全复制并确保即使写入（服务器失败的情况下写入就不会完成）。

Kafka的磁盘结构可以很好地扩展使用-无论服务器上有50 KB还是50 TB的持久数据，Kafka都将执行相同的操作。

由于严谨对待存储并允许客户端控制其读取位置，因此您可以将Kafka视为一种专用于高性能，低延迟提交日志存储，复制和传播的专用分布式文件系统。

#### Kafka用于流处理
仅读取，写入和存储数据流是不够的，kafka的目的是实现对流的实时处理。

在Kafka中，流处理器是指从输入topic中获取连续数据流，对该输入进行一些处理并生成连续数据流以输出topic的任何东西。

例如，零售应用程序可以接受销售和装运的输入流，并输出根据此数据计算出的重新订购和价格调整流。

可以直接使用producer和consumer API进行简单处理。 但是，对于更复杂的转换，Kafka提供了完全集成的Streams API。 这允许构建执行非重要处理的应用程序，这些应用程序计算流的聚合或将流连接在一起。

该功能有助于解决此类应用程序所面临的难题：处理无序数据，在代码更改时重新处理输入，执行状态计算等。

Stream API建立在Kafka提供的核心原件之上：它使用生产者和使用者API进行输入，使用Kafka进行状态存储，并使用相同的组机制来实现流处理器实例之间的容错。

### 消息队列的好处
#### 1.解耦
允许你独立的扩展或修改两边的处理过程，只要确保他们遵守同样的接口约束

#### 2.可恢复性
系统的一部分组件失效时，不会影响到整个系统。消息队列降低了进程间的耦合度，所以即使一个处理消息的进程挂掉，加入队列中的消息仍然可以在系统恢复后被处理。

#### 3.缓冲
有助于控制和优化数据流经过系统的速度，解决生产消息和消费消息的处理速度不一致的情况（生产速度大于消费速度）

#### 4.灵活性和峰值处理能力
在访问量剧增的情况下，应用仍然需要继续发挥作用，但是这样的突发流量不常见。如果为以能处理这类峰值访问为标准来投入资源随时待命无疑是巨大的浪费。使用消息队列能够使关键组件顶住突发的访问压力，而不会因为突发的超负荷的请求而完全崩溃。

#### 5.异步通信
很多时候，用户不想也不需要立即处理消息。消息队列提供了异步处理机制，允许用户把一个消息放入队列，但并不立即处理它。想向队列中放入多少消息，就放多少消息，然后在需要时再去处理它们。

### 消息队列的两种模式
#### 1.点对点模式（一对一，消费者主动拉去数据，消息收到后消息清除）
消息生产者产生消息发送到Queue中，然后消息消费者从Queue中取出并且消费消息。消息被消费之后，queue中不再有存储，所以消息消费者不可能消费到已经被消费的消息。Queue支持存在多个消费者，但是对一个消息而言，只会有一个消费者可以消费。

#### 2.发布/订阅模式（一对多，消费者消费数据之后不会清除消息）
消息生产者（发布）将消息发布到topic中，同时有多个消费者（订阅）消费该消息。和点对点方式不同，发布到topic的消息会被所有订阅者消费。

发布/订阅模式又有两种区分：

##### ①生产者主动推送消息给消费者
生产者主动推送的方式的缺点是不能够知道每个消费者的消费能力如何。假如生产者恒定以50m/s的带宽推给能消费100m/s带宽的消费者A和能消费10m/s带宽的消费者B，那么会造成A资源浪费，而B崩溃。

##### ②消费者主动拉取队列中的消息。（kafka用的是这种）
消费者主动拉取的方式能很好的解决模型①中的问题。消费者按照自己的消费能力来拉去数据。但是模型②也有缺点：消费者必须轮询访问消息队列来确认是否有消息可以消费，这会有一定的请求资源浪费。
