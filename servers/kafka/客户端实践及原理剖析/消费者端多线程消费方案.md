从Kafka0.10.1.0版本开始，KafkaConsumer变为了双线程设计，即用户主线程和心跳线程。不过，虽然有心跳线程，但实际的消息获取逻辑依然是在用户主线程中完成的。因此，在消费消息的这个层面上，我们依然可以安全地认为KafkaConsumer是单线程的设计。

鉴于KafkaConsumer不是线程安全的事实，我们能够定制两套多线程消费方案：
1. 消费者程序启动多个线程，每个线程维护专属的KafkaConsumer实例，负责完整的消息获取、消息处理流程；
2. 消费者程序使用单线程或多线程获取消息，同时创建多个线程来执行消息处理逻辑。

两种方案的优缺点：

##### 多线程+多KafkaConsumer实例维护整个消息获取和消息处理方案
###### 优点
1. 实现起来简单，因为它比较符合目前我们使用 Consumer API 的习惯。
2. 多个线程之间彼此没有任何交互，省去了很多保障线程安全方面的开销
3. 容易实现分区内的消息消费顺序

###### 缺点
1. 占用系统资源。每个线程都维护自己的 KafkaConsumer 实例，必然会占用更多的系统资源，比如内存、TCP 连接等。
2. 受限于Consumer订阅主题的总分区数。
3. 每个线程完整地执行消息获取和消息处理逻辑。**一旦消息处理逻辑很重，造成消息处理速度慢，就很容易出现不必要的 Rebalance**，从而引发整个消费者组的消费停滞。

##### 切分消息获取和消息处理方案
###### 优点
1. 高伸缩性。可以独立地调节消息获取的线程数，以及消息处理的线程数

###### 缺点
1. 实现难度大，毕竟它有两组线程，你需要分别管理它们
2. 无法保证分区内的消费顺序
3. 整个消息消费链路被拉长，最终导致**正确位移提交会变得异常困难，结果就是可能会出现消息的重复消费**。
