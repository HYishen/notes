### String类型
string是redis最基本的类型。其数据结构是简单的key-value类型。value不仅是string，也可以是数字，是包含很多种类型的特殊类型。

string类型是二进制安全的。意思是redis的string可以包含任何数据。比如jpg图片或者序列化的对象。

string类型是Redis最基本的数据类型，string类型的值最大能存储512MB。

#### string应用场景
1. String通常用于保存单个字符串或json字符串数据

2. 因String是二进制安全的，所以你完全可以把一个图片文件的内容作为字符串来存储

3. 计数器（常规key-value缓存应用。常规计数：微博数，粉丝数）

4. 分布式锁。在一个集群环境下，多个web应用时对同一个商品进行抢购和减库存操作时，可能出现超卖时会用到分布式锁。使用SETNX命令（SET if Not eXists）

>INCR等指令本身就具有原子操作的特性，所以我们完全可以利用redis的INCR、INCRBY、DECR、DECRBY等指令来实现原子计数的效果。

### Hash类型
Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。

可以看成具有key和value的map容器，该类型非常适合于存储值对象信息。

Redis 中每个 hash 可以存储 232 - 1 键值对（40多亿）。

#### Hash内部编码
哈希类型 的 内部编码 有两种：

##### ziplist（压缩列表）
当 哈希类型 元素个数 小于 hash-max-ziplist-entries 配置（默认 512 个）、同时 所有值 都 小于 hash-max-ziplist-value 配置（默认 64 字节）时，Redis 会使用 ziplist 作为 哈希 的 内部实现，ziplist 使用更加 紧凑的结构 实现多个元素的 连续存储，所以在 节省内存 方面比 hashtable 更加优秀。

##### hashtable（哈希表）
当 哈希类型 无法满足 ziplist 的条件时，Redis 会使用 hashtable 作为 哈希 的 内部实现，因为此时 ziplist 的 读写效率 会下降，而 hashtable 的读写 时间复杂度 为 O（1）。

### List类型
Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。List类型相当于是一个双向链表。

一个列表最多可以包含 232 - 1 个元素 (4294967295, 每个列表超过40亿个元素)。

#### 列表的特点
1.列表中的元素是有序的，可以通过索引下标来获取某个元素或者某个范围内的元素列表

2.列表中的元素是可以重复的

#### List命令tips
获取列表时，-1表示最后一个下标的元素，-2表示倒数第二个下标的元素。

例如，获取列表中第一到倒数第二的元素
```
lrange list 0 -2
```

### Set类型
Redis 的 Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。

Redis 中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。

集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。

### ZSet类型
Redis 有序集合和集合一样也是string类型元素的集合,且不允许重复的成员。

不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。

有序集合的成员是唯一的,但分数(score)却可以重复。

集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。 集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。

其实在redis sorted sets里面当items内容大于64的时候同时使用了hash和skiplist两种设计实现。这也会为了排序和查找性能做的优化。

所以如上可知：

添加和删除都需要修改skiplist，所以复杂度为O(log(n))。 

但是如果仅仅是查找元素的话可以直接使用hash，其复杂度为O(1) 

其他的range操作复杂度一般为O(log(n))

当然如果是小于64的时候，因为是采用了ziplist的设计，其时间复杂度为O(n)

### HyperLogLog类型
Redis 在 2.8.9 版本添加了 HyperLogLog 结构。

Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定 的、并且是很小的。

在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基 数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。

但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。

#### 什么是基数?
比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}, 基数(不重复元素)为5。 基数估计就是在误差可接受的范围内，快速计算基数。
